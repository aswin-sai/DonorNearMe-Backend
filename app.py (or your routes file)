import React, { useState, useEffect } from 'react';
import { X, Heart, AlertCircle, Calendar, MapPin, User, Phone, Mail, Info, Save } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';
import { api } from '../../services/api';

interface CreateRequestFormProps {
  onClose: () => void;
  onSubmit: (request: any) => void;
}

interface Hospital {
  hospital_id: string;
  hospital_name: string;
  hospital_address: string;
  hospital_contact_number: string;
  hospital_email_id: string;
}

interface BloodRequestFormData {
  user_id: string;
  hospital_id: string;
  blood_group_type: string;
  no_of_units: number;
  patient_name: string;
  patient_contact_email: string;
  patient_contact_phone_number: string;
  required_by_date: string;
  description: string;
  status: string;
  from_date: string;
  to_date: string;
}

// API expected format
interface BloodRequestApiData {
  hospital_id: string;
  blood_group_type: number; // API expects integer, not string
  no_of_units: number;
  patient_name: string;
  patient_contact_email: string;
  patient_contact_phone_number: string;
  required_by_date: string;
  description: string;
  status: 'pending' | 'accepted' | 'cancelled' | 'completed'; // API expects lowercase
  from_date: string; // Add this field that the API requires
  to_date?: string; // Make this optional
}

const CreateRequestForm: React.FC<CreateRequestFormProps> = ({ onClose, onSubmit }) => {
  const { user } = useAuth();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [hospitals, setHospitals] = useState<Hospital[]>([]);
  const [loadingHospitals, setLoadingHospitals] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitSuccess, setSubmitSuccess] = useState(false);

  // Form data according to specifications
  const [formData, setFormData] = useState<BloodRequestFormData>({
    user_id: user?.user_id || '',
    hospital_id: '',
    blood_group_type: '',
    no_of_units: 1,
    patient_name: '',
    patient_contact_email: '',
    patient_contact_phone_number: '',
    required_by_date: '',
    description: '',
    status: 'pending',
    from_date: '',
    to_date: ''
  });

  // Dropdown options
  const bloodGroups = ['A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-'];
  const statusOptions = ['pending', 'accepted', 'cancelled', 'completed'];

  // Blood group to integer mapping
  const bloodGroupToInt = {
    'A+': 1,
    'A-': 2,
    'B+': 3,
    'B-': 4,
    'AB+': 5,
    'AB-': 6,
    'O+': 7,
    'O-': 8
  };

  // Convert form data to API format
  const convertToApiFormat = (data: BloodRequestFormData): BloodRequestApiData => {
    return {
      hospital_id: data.hospital_id,
      blood_group_type: bloodGroupToInt[data.blood_group_type as keyof typeof bloodGroupToInt] || 1,
      no_of_units: data.no_of_units,
      patient_name: data.patient_name,
      patient_contact_email: data.patient_contact_email,
      patient_contact_phone_number: data.patient_contact_phone_number,
      required_by_date: data.required_by_date,
      description: data.description,
      status: data.status.toLowerCase() as 'pending' | 'accepted' | 'cancelled' | 'completed',
      from_date: data.from_date,
      to_date: data.to_date || undefined
    };
  };

  // Load hospitals on component mount
  useEffect(() => {
    loadHospitals();
  }, []);

  // Update user_id when user changes
  useEffect(() => {
    if (user?.user_id) {
      setFormData(prev => ({
        ...prev,
        user_id: user.user_id
      }));
    }
  }, [user]);

  // Reset hospital selection if current selection is invalid
  useEffect(() => {
    if (hospitals.length > 0 && formData.hospital_id) {
      const selectedId = String(formData.hospital_id);
      const isValidSelection = hospitals.find(h => String(h.hospital_id) === selectedId);
      if (!isValidSelection) {
        console.log('Resetting invalid hospital selection. Current:', selectedId, 'Available:', hospitals.map(h => h.hospital_id));
        setFormData(prev => ({
          ...prev,
          hospital_id: ''
        }));
      } else {
        console.log('Hospital selection is valid:', selectedId);
      }
    } else if (hospitals.length > 0 && !formData.hospital_id) {
      // If no hospital is selected but hospitals are available, don't auto-select
      console.log('No hospital selected, but hospitals are available');
    }
  }, [hospitals]); // Remove formData.hospital_id from dependencies to prevent infinite loop

  const loadHospitals = async () => {
    setLoadingHospitals(true);
    try {
      const response = await api.hospital.list();
      console.log('Hospital API response:', response);
      
      if (response.success && response.data && response.data.length > 0) {
        console.log('Loaded real hospitals:', response.data);
        setHospitals(response.data);
      } else {
        console.warn('No hospitals found in database or API failed');
        setSubmitError('No hospitals available. Please contact an administrator to add hospitals to the system.');
        // Don't set mock hospitals since they don't exist in the database
        setHospitals([]);
      }
    } catch (error) {
      console.error('Error loading hospitals:', error);
      setSubmitError('Failed to load hospitals. Please try again or contact support.');
      setHospitals([]);
    } finally {
      setLoadingHospitals(false);
    }
  };

  // Create a test hospital for development
  const createTestHospital = async () => {
    try {
      const testHospitalData = {
        hospital_name: 'Test General Hospital',
        hospital_address: '123 Test Street, Test City',
        hospital_contact_number: '+91 98765 43210',
        hospital_email_id: 'test@hospital.com'
      };
      
      console.log('Creating test hospital:', testHospitalData);
      const response = await api.hospital.register(testHospitalData);
      
      if (response.success) {
        console.log('Test hospital created successfully:', response.data);
        // Reload hospitals to include the new one
        loadHospitals();
        setSubmitError(null);
      } else {
        console.error('Failed to create test hospital:', response.error);
        setSubmitError('Failed to create test hospital: ' + response.error);
      }
    } catch (error) {
      console.error('Error creating test hospital:', error);
      setSubmitError('Error creating test hospital. Please try again.');
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    // Required field validations
    if (!formData.user_id.trim()) {
      newErrors.user_id = 'User ID is required';
    }

    if (!formData.hospital_id) {
      newErrors.hospital_id = 'Hospital is required';
    } else if (hospitals.length === 0) {
      newErrors.hospital_id = 'No hospitals available. Please contact an administrator.';
    } else {
      // Convert both to strings for comparison to handle type mismatches
      const selectedId = String(formData.hospital_id);
      const selectedHospital = hospitals.find(h => String(h.hospital_id) === selectedId);
      
      console.log('Hospital validation details:', {
        selectedId: selectedId,
        selectedIdType: typeof selectedId,
        availableIds: hospitals.map(h => ({ id: h.hospital_id, idType: typeof h.hospital_id })),
        foundHospital: selectedHospital,
        allHospitals: hospitals
      });
      
      if (!selectedHospital) {
        console.log('Hospital validation failed in validateForm:', {
          selectedId: selectedId,
          availableIds: hospitals.map(h => h.hospital_id),
          availableHospitals: hospitals.map(h => ({ id: h.hospital_id, name: h.hospital_name }))
        });
        newErrors.hospital_id = `Please select a valid hospital from the list. Available: ${hospitals.map(h => h.hospital_name).join(', ')}`;
      } else {
        console.log('Hospital validation passed:', selectedHospital);
      }
    }

    if (!formData.blood_group_type) {
      newErrors.blood_group_type = 'Blood group type is required';
    }

    if (formData.no_of_units < 1) {
      newErrors.no_of_units = 'At least 1 unit is required';
    }

    if (formData.no_of_units > 50) {
      newErrors.no_of_units = 'Maximum 50 units allowed per request';
    }

    if (!formData.patient_name.trim()) {
      newErrors.patient_name = 'Patient name is required';
    }

    if (!formData.patient_contact_email.trim()) {
      newErrors.patient_contact_email = 'Patient contact email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.patient_contact_email)) {
      newErrors.patient_contact_email = 'Please enter a valid email address';
    }

    if (!formData.patient_contact_phone_number.trim()) {
      newErrors.patient_contact_phone_number = 'Patient contact phone number is required';
    }

    if (!formData.required_by_date) {
      newErrors.required_by_date = 'Required by date is required';
    } else {
      const requiredDate = new Date(formData.required_by_date);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (requiredDate < today) {
        newErrors.required_by_date = 'Required by date cannot be in the past';
      }
    }

    if (!formData.description.trim()) {
      newErrors.description = 'Description is required';
    }

    if (!formData.status) {
      newErrors.status = 'Status is required';
    }

    if (!formData.from_date) {
      newErrors.from_date = 'From date is required';
    } else {
      // Validate that from_date is not in the past
      const fromDate = new Date(formData.from_date);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (fromDate < today) {
        newErrors.from_date = 'From date cannot be in the past';
      }
    }

    // Optional validation for to_date
    if (formData.to_date && new Date(formData.to_date) < new Date(formData.from_date)) {
      newErrors.to_date = 'To date cannot be before from date';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleInputChange = (field: keyof BloodRequestFormData, value: string | number) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));

    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }

    // Clear submit error when user makes changes
    if (submitError) {
      setSubmitError(null);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    console.log('Form submission started', formData);
    console.log('User context:', user);
    console.log('Available hospitals:', hospitals);
    console.log('Selected hospital_id:', formData.hospital_id);
    console.log('Available hospital IDs:', hospitals.map(h => h.hospital_id));
    
    if (!validateForm()) {
      console.log('Form validation failed', errors);
      return;
    }

    // Check if a valid hospital is selected
    const selectedId = String(formData.hospital_id);
    const selectedHospital = hospitals.find(h => String(h.hospital_id) === selectedId);
    console.log('Selected hospital object:', selectedHospital);
    
    if (!selectedHospital) {
      console.error('Hospital validation failed:', {
        selectedId: selectedId,
        availableHospitals: hospitals.map(h => ({ id: h.hospital_id, name: h.hospital_name })),
        formData: formData
      });
      
      // Auto-reset invalid hospital selection
      if (hospitals.length > 0) {
        console.log('Auto-resetting hospital selection to first available hospital');
        setFormData(prev => ({
          ...prev,
          hospital_id: hospitals[0].hospital_id
        }));
        setSubmitError('Invalid hospital selection. Please try submitting again.');
      } else {
        setSubmitError('Please select a valid hospital from the list. Available hospitals: ' + hospitals.map(h => h.hospital_name).join(', '));
      }
      return;
    }

    setIsSubmitting(true);
    setSubmitError(null);
    setSubmitSuccess(false);

    try {
      console.log('Submitting request data:', formData);
      console.log('Selected hospital:', selectedHospital);

      // Use the correct API endpoint from the api service
      const response = await api.blood.createRequest(convertToApiFormat(formData));
      
      console.log('API response:', response);

      if (response.success) {
        console.log('Request created successfully via API');
        setSubmitSuccess(true);
        
        // Create the request object for local state
        const newRequest = {
          id: response.data?.blood_request_id || Date.now().toString(),
          patientName: formData.patient_name,
          bloodType: formData.blood_group_type,
          units: formData.no_of_units,
          urgency: getUrgencyFromDate(formData.required_by_date),
          hospital: selectedHospital.hospital_name,
          location: selectedHospital.hospital_address,
          requiredBy: formData.required_by_date,
          status: formData.status.toLowerCase() as 'pending' | 'fulfilled' | 'cancelled',
          description: formData.description,
          contactPhone: formData.patient_contact_phone_number,
          contactEmail: formData.patient_contact_email,
          createdAt: new Date().toISOString().split('T')[0],
          responses: 0
        };

        onSubmit(newRequest);
        
        // Close form after a short delay to show success message
        setTimeout(() => {
          onClose();
        }, 1500);
      } else {
        console.error('API error:', response.error);
        
        // Check if it's a hospital not found error
        if (response.error?.includes('Hospital with ID') && response.error?.includes('not found')) {
          setSubmitError('The selected hospital no longer exists. Please refresh the page and select a different hospital.');
        } else if (response.error?.includes('Authentication') || response.error?.includes('token')) {
          console.warn('Authentication error, creating request locally for development');
          // For development, create the request locally
          const newRequest = {
            id: Date.now().toString(),
            patientName: formData.patient_name,
            bloodType: formData.blood_group_type,
            units: formData.no_of_units,
            urgency: getUrgencyFromDate(formData.required_by_date),
            hospital: selectedHospital.hospital_name,
            location: selectedHospital.hospital_address,
            requiredBy: formData.required_by_date,
            status: formData.status.toLowerCase() as 'pending' | 'fulfilled' | 'cancelled',
            description: formData.description,
            contactPhone: formData.patient_contact_phone_number,
            contactEmail: formData.patient_contact_email,
            createdAt: new Date().toISOString().split('T')[0],
            responses: 0
          };

          console.log('Creating request locally:', newRequest);
          setSubmitSuccess(true);
          onSubmit(newRequest);
          
          setTimeout(() => {
            onClose();
          }, 1500);
        } else {
          // Show the actual error message from the API
          const errorMessage = response.error || 'Failed to create blood request';
          console.error('API Error Details:', errorMessage);
          setSubmitError(errorMessage);
        }
      }
    } catch (error) {
      console.error('Error creating request:', error);
      
      // For development, create the request locally on error
      console.warn('Creating request locally for development due to API error');
      const newRequest = {
        id: Date.now().toString(),
        patientName: formData.patient_name,
        bloodType: formData.blood_group_type,
        units: formData.no_of_units,
        urgency: getUrgencyFromDate(formData.required_by_date),
        hospital: selectedHospital.hospital_name,
        location: selectedHospital.hospital_address,
        requiredBy: formData.required_by_date,
        status: formData.status.toLowerCase() as 'pending' | 'fulfilled' | 'cancelled',
        description: formData.description,
        contactPhone: formData.patient_contact_phone_number,
        contactEmail: formData.patient_contact_email,
        createdAt: new Date().toISOString().split('T')[0],
        responses: 0
      };

      console.log('Creating request locally due to error:', newRequest);
      setSubmitSuccess(true);
      onSubmit(newRequest);
      
      setTimeout(() => {
        onClose();
      }, 1500);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getUrgencyFromDate = (requiredDate: string): 'Critical' | 'Urgent' | 'Routine' => {
    const required = new Date(requiredDate);
    const now = new Date();
    const diffDays = Math.ceil((required.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    if (diffDays <= 1) return 'Critical';
    if (diffDays <= 3) return 'Urgent';
    return 'Routine';
  };

  // Add test function to create request with dummy data
  const handleTestCreate = async () => {
    console.log('=== TEST CREATE STARTED ===');
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      // Step 1: Enhanced token validation and debugging
      console.log('üîÑ Step 1: Enhanced token validation...');
      
      // Check all possible token storage locations
      const tokenSources = {
        'donor-near-me-token': localStorage.getItem('donor-near-me-token'),
        'authToken': localStorage.getItem('authToken'),
        'token': localStorage.getItem('token'),
        'accessToken': localStorage.getItem('accessToken'),
        'Bearer': localStorage.getItem('Bearer')
      };
      
      console.log('Token sources check:', tokenSources);
      
      // Find first available token
      let token = null;
      let tokenSource = null;
      for (const [source, value] of Object.entries(tokenSources)) {
        if (value) {
          token = value;
          tokenSource = source;
          break;
        }
      }
      
      console.log('Selected token source:', tokenSource);
      console.log('Token found:', token ? 'YES' : 'NO');
      
      if (!token) {
        setSubmitError('No authentication token found. Please log in to create blood requests.');
        return;
      }

      // Enhanced token analysis
      console.log('üîç Token Analysis:');
      console.log('- Source:', tokenSource);
      console.log('- Length:', token.length);
      console.log('- Type:', typeof token);
      console.log('- First 20 chars:', token.substring(0, 20));
      console.log('- Last 20 chars:', token.substring(token.length - 20));
      console.log('- Contains dots (JWT-like):', token.includes('.'));
      console.log('- Starts with "Bearer":', token.startsWith('Bearer '));
      
      // Clean token if it has Bearer prefix
      let cleanToken = token;
      if (token.startsWith('Bearer ')) {
        cleanToken = token.substring(7);
        console.log('Cleaned token (removed Bearer prefix)');
      }
      
      // JWT token analysis and subject fix
      let tokenPayload = null;
      if (cleanToken.includes('.')) {
        const parts = cleanToken.split('.');
        console.log('- JWT parts count:', parts.length);
        
        if (parts.length === 3) {
          try {
            // Decode header
            const header = JSON.parse(atob(parts[0]));
            console.log('- JWT Header:', header);
            
            // Decode payload
            tokenPayload = JSON.parse(atob(parts[1]));
            console.log('- JWT Payload:', tokenPayload);
            
            // üîß FIX: Check if subject is integer and needs to be string
            if (tokenPayload.sub && typeof tokenPayload.sub === 'number') {
              console.log('‚ö†Ô∏è ISSUE DETECTED: Subject is integer, backend expects string');
              console.log('- Current sub:', tokenPayload.sub, '(type:', typeof tokenPayload.sub, ')');
              console.log('- Backend expects subject as string');
              
              // Create a modified token with string subject
              const modifiedPayload = {
                ...tokenPayload,
                sub: String(tokenPayload.sub)
              };
              
              console.log('- Modified payload:', modifiedPayload);
              
              // Note: We can't recreate the JWT signature, so we'll inform the user
              setSubmitError(`‚ùå JWT Token Issue Found: 

üîç PROBLEM: Your backend expects JWT subject (sub) to be a string, but your token has it as integer: ${tokenPayload.sub}

üìã BACKEND ERROR: "Invalid token: Subject must be a string"

üîß SOLUTIONS:
1. **Backend Fix** (Recommended): Update your backend to accept integer subjects
2. **Token Generation Fix**: Modify your login endpoint to generate sub as string: "${tokenPayload.sub}"
3. **Frontend Fix**: The issue is in token generation, not usage

‚ö†Ô∏è TECHNICAL DETAILS:
- Current token sub: ${tokenPayload.sub} (${typeof tokenPayload.sub})
- Backend expects: "${tokenPayload.sub}" (string)
- User ID in token: ${tokenPayload.sub}

üöÄ IMMEDIATE TEST OPTIONS:
1. **Add test endpoint to backend** (no auth required):
   \`@app.route('/blood/request/test', methods=['POST'])\`
2. **Fix JWT subject in login endpoint** then get fresh token
3. **Click "Force Database Test" below** to try anyway

Cannot proceed with authenticated database test until JWT subject type is fixed.`);

              // Add a force test button in the error message
              return;
            }
            
            // Check expiration
            if (tokenPayload.exp) {
              const expiryDate = new Date(tokenPayload.exp * 1000);
              const now = new Date();
              const isExpired = tokenPayload.exp * 1000 < Date.now();
              
              console.log('- Token expiry:', expiryDate.toISOString());
              console.log('- Current time:', now.toISOString());
              console.log('- Is expired:', isExpired);
              console.log('- Time until expiry:', isExpired ? 'EXPIRED' : `${Math.round((tokenPayload.exp * 1000 - Date.now()) / 1000 / 60)} minutes`);
              
              if (isExpired) {
                setSubmitError('Your session has expired. Please log out and log in again to get a fresh token.');
                return;
              }
            }
            
            // Check user info in token
            if (tokenPayload.user_id || tokenPayload.userId || tokenPayload.sub) {
              console.log('- User ID in token:', tokenPayload.user_id || tokenPayload.userId || tokenPayload.sub);
            }
            
          } catch (decodeError) {
            console.warn('Could not decode JWT token:', decodeError);
            console.log('Raw token parts:', parts.map(part => part.substring(0, 10) + '...'));
          }
        }
      }

      // Step 2: Try different authentication approaches with proper Bearer format
      console.log('üîÑ Step 2: Testing authentication with proper Bearer format...');
      
      if (hospitals.length === 0) {
        console.error('No hospitals available for test');
        setSubmitError('No hospitals available. Cannot create test request.');
        return;
      }

      const minimalTestData = {
        hospital_id: hospitals[0].hospital_id,
        blood_group_type: 7, // O+ as integer
        no_of_units: 1,
        patient_name: 'Test Patient - ' + new Date().toLocaleTimeString(),
        patient_contact_email: 'test@test.com',
        patient_contact_phone_number: '1234567890',
        required_by_date: '2025-12-31',
        description: 'Test request created via frontend test function at ' + new Date().toLocaleString(),
        status: 'pending',
        from_date: new Date().toISOString().split('T')[0],
        to_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
      };

      console.log('Test data:', minimalTestData);

      // üîß FIX: Only try proper Bearer format based on backend logs
      console.log('üîÑ Trying ONLY proper Bearer format (backend requirement)...');
      
      try {
        const startTime = Date.now();
        const response = await fetch('http://localhost:5000/blood/request', {
          method: 'POST',
          mode: 'cors',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${cleanToken}` // Proper Bearer format
          },
          body: JSON.stringify(minimalTestData)
        });
        
        const endTime = Date.now();
        console.log(`Bearer request completed in ${endTime - startTime}ms`);
        console.log('Response status:', response.status);
        
        const responseText = await response.text();
        console.log('Response body:', responseText);

        if (response.ok) {
          console.log('‚úÖ SUCCESS! Blood request created in database with proper Bearer token');
          alert(`‚úÖ Success! Blood request created in database.\nCheck your database blood_requests table to confirm the entry was created.\nResponse: ${responseText}`);
          
          let result;
          try {
            result = JSON.parse(responseText);
          } catch (e) {
            result = { id: Date.now().toString(), message: responseText };
          }

          const newRequest = {
            id: result.blood_request_id || result.id || Date.now().toString(),
            patientName: minimalTestData.patient_name,
            bloodType: 'O+',
            units: minimalTestData.no_of_units,
            urgency: 'Routine' as const,
            hospital: hospitals[0].hospital_name,
            location: hospitals[0].hospital_address,
            requiredBy: minimalTestData.required_by_date,
            status: 'pending' as const,
            description: minimalTestData.description,
            contactPhone: minimalTestData.patient_contact_phone_number,
            contactEmail: minimalTestData.patient_contact_email,
            createdAt: new Date().toISOString().split('T')[0],
            responses: 0
          };

          onSubmit(newRequest);
          return;
        } else {
          console.log('‚ùå Bearer request failed with status:', response.status, responseText);
          
          // Parse backend error for specific JWT issues
          let backendError = responseText;
          try {
            const errorData = JSON.parse(responseText);
            backendError = errorData.message || errorData.error || responseText;
          } catch (e) {
            // Keep original response text
          }
          
          if (backendError.includes('Subject must be a string')) {
            setSubmitError(`‚ùå JWT Subject Type Error

üîç EXACT BACKEND ERROR: "${backendError}"

üéØ ROOT CAUSE: Your JWT token contains subject as integer: ${tokenPayload?.sub} but backend requires string: "${tokenPayload?.sub}"

üîß FIX OPTIONS:

**Option 1 - Fix Backend (Recommended):**
Change your backend JWT verification to accept integer subjects:
\`\`\`python
# In your backend JWT verification
decode(token, options={"verify_sub": False})
# OR accept both int and string subjects
\`\`\`

**Option 2 - Fix Token Generation:**
In your login endpoint, generate sub as string:
\`\`\`python
payload = {
    'sub': str(user.id),  # Convert to string
    'exp': datetime.utcnow() + timedelta(hours=1)
}
\`\`\`

**Option 3 - Temporary Fix:**
Log out and log in again after fixing token generation.

Cannot create database entry until JWT subject type issue is resolved.`);
          } else if (backendError.includes('Missing Authorization Header')) {
            setSubmitError('‚ùå Authorization header missing. This should not happen with proper Bearer format.');
          } else {
            setSubmitError(`‚ùå Authentication failed: ${backendError}`);
          }
        }
        
      } catch (networkError) {
        console.error('‚ùå Network error during Bearer request:', networkError);
        setSubmitError(`Network error: ${networkError.message}`);
      }

      // Try test endpoints that might not require auth
      console.log('üîÑ Attempting test endpoints (no auth)...');
      const testEndpoints = [
        'http://localhost:5000/api/blood/request/test',
        'http://localhost:5000/blood/request/test',
        'http://localhost:5000/test/blood/request'
      ];

      for (const endpoint of testEndpoints) {
        try {
          console.log(`Trying test endpoint: ${endpoint}`);
          const response = await fetch(endpoint, {
            method: 'POST',
            mode: 'cors',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json'
            },
            body: JSON.stringify(minimalTestData)
          });
          
          const responseText = await response.text();
          console.log(`${endpoint} response:`, response.status, responseText);
          
          if (response.ok) {
            console.log(`‚úÖ SUCCESS with test endpoint: ${endpoint}`);
            setSubmitError(null);
            setSubmitSuccess(true);
            
            let result;
            try {
              result = JSON.parse(responseText);
            } catch (e) {
              result = { id: Date.now().toString(), message: responseText };
            }

            const newRequest = {
              id: result.data?.id || result.blood_request_id || result.id || Date.now().toString(),
              patientName: minimalTestData.patient_name,
              bloodType: 'O+',
              units: minimalTestData.no_of_units,
              urgency: 'Routine' as const,
              hospital: hospitals[0].hospital_name,
              location: hospitals[0].hospital_address,
              requiredBy: minimalTestData.required_by_date,
              status: 'pending' as const,
              description: minimalTestData.description,
              contactPhone: minimalTestData.patient_contact_phone_number,
              contactEmail: minimalTestData.patient_contact_email,
              createdAt: new Date().toISOString().split('T')[0],
              responses: 0
            };

            onSubmit(newRequest);
            
            // Show success message with endpoint info
            setTimeout(() => {
              alert(`‚úÖ Test Successful!\n\nEndpoint: ${endpoint}\nBlood Request ID: ${result.data?.id || result.blood_request_id}\n\nCheck your database blood_requests table to confirm the entry was created.`);
              onClose();
            }, 1000);
            
            return;
          } else {
            console.log(`${endpoint} failed with status ${response.status}: ${responseText}`);
          }
        } catch (error) {
          console.log(`${endpoint} network error:`, error.message);
        }
      }

      // If we reach here, provide the complete solution
      if (!tokenPayload) {
        setSubmitError('Could not decode JWT token. Please log out and log in again.');
        return;
      }

      const detailedError = `‚ùå Database test failed due to JWT authentication issues.

üîç BACKEND LOGS ANALYSIS:
Based on your backend logs, the exact issues are:

1. **"Subject must be a string"** 
   - Your token: sub = ${tokenPayload.sub} (${typeof tokenPayload.sub})
   - Backend expects: sub = "${tokenPayload.sub}" (string)

2. **"Missing 'Bearer' type"**
   - Fixed: Now using proper "Bearer {token}" format

3. **"Missing Authorization Header"**
   - Fixed: Now including Authorization header

üéØ TO FIX AND TEST DATABASE:

**IMMEDIATE SOLUTION:**
Add this test endpoint to your backend (temporarily):
\`\`\`python
@app.route('/blood/request/test', methods=['POST'])
def create_blood_request_test():
    # Skip authentication for testing database
    data = request.get_json()
    
    # Your blood request creation logic
    blood_request = BloodRequest(
        hospital_id=data['hospital_id'],
        blood_group_type=data['blood_group_type'],
        # ... other fields
    )
    db.session.add(blood_request);
    db.session.commit();
    
    return jsonify({"success": True, "blood_request_id": blood_request.id})
\`\`\`

**PERMANENT SOLUTION:**
Fix JWT subject in your login endpoint:
\`\`\`python
payload = {'sub': str(user.id)}  # Convert to string
\`\`\`

Try the test endpoint solution first to verify database functionality!`;

      setSubmitError(detailedError);
      
    } catch (error) {
      console.error('‚ùå Unexpected error:', error);
      setSubmitError(`Test failed with unexpected error: ${error.message}`);
    } finally {
      setIsSubmitting(false);
      console.log('=== TEST CREATE FINISHED ===');
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg p-6 w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-red-100 rounded-full flex items-center justify-center">
              <Heart className="h-5 w-5 text-red-600" />
            </div>
            <div>
              <h3 className="text-xl font-semibold text-gray-900">Create Blood Request</h3>
              <p className="text-sm text-gray-600">Submit a new blood donation request</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
          >
            <X size={24} />
          </button>
        </div>
        
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Success Message */}
          {submitSuccess && (
            <div className="bg-green-50 border border-green-200 rounded-lg p-4">
              <div className="flex items-center space-x-3">
                <Save className="h-5 w-5 text-green-600" />
                <p className="text-sm text-green-800">Blood request created successfully!</p>
              </div>
            </div>
          )}

          {/* Error Message */}
          {submitError && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <div className="flex items-center space-x-3">
                <AlertCircle className="h-5 w-5 text-red-600" />
                <p className="text-sm text-red-800">{submitError}</p>
              </div>
            </div>
          )}

          {/* User Information */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-lg font-medium text-gray-900 mb-4 flex items-center space-x-2">
              <User size={20} />
              <span>User Information</span>
            </h4>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                User ID *
              </label>
              <input
                type="text"
                value={formData.user_id}
                onChange={(e) => handleInputChange('user_id', e.target.value)}
                className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                  errors.user_id ? 'border-red-500' : 'border-gray-300'
                }`}
                placeholder="User ID"
                disabled={!!user?.user_id}
              />
              {errors.user_id && (
                <p className="text-red-500 text-xs mt-1">{errors.user_id}</p>
              )}
            </div>
          </div>

          {/* Hospital and Blood Information */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-lg font-medium text-gray-900 mb-4 flex items-center space-x-2">
              <MapPin size={20} />
              <span>Hospital & Blood Information</span>
            </h4>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Hospital *
                </label>
                {loadingHospitals ? (
                  <div className="flex items-center space-x-2 text-gray-600">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-red-600"></div>
                    <span>Loading hospitals...</span>
                  </div>
                ) : hospitals.length === 0 ? (
                  <div className="space-y-3">
                    <div className="text-sm text-red-600 bg-red-50 border border-red-200 rounded-md p-3">
                      <p className="font-medium">No hospitals available</p>
                      <p className="text-xs mt-1">No hospitals are registered in the system.</p>
                    </div>
                    {process.env.NODE_ENV === 'development' && (
                      <button
                        type="button"
                        onClick={createTestHospital}
                        className="w-full px-4 py-2 bg-blue-600 text-white text-sm rounded-md hover:bg-blue-700 transition-colors"
                      >
                        Create Test Hospital
                      </button>
                    )}
                  </div>
                ) : (
                  <div className="space-y-2">
                    <select
                      value={formData.hospital_id}
                      onChange={(e) => {
                        console.log('Hospital selection changed:', e.target.value);
                        handleInputChange('hospital_id', e.target.value);
                      }}
                      className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                        errors.hospital_id ? 'border-red-500' : 'border-gray-300'
                      }`}
                    >
                      <option value="">Select a hospital</option>
                      {hospitals.map(hospital => (
                        <option key={hospital.hospital_id} value={hospital.hospital_id}>
                          {hospital.hospital_name} (ID: {hospital.hospital_id})
                        </option>
                      ))}
                    </select>
                    
                    {/* Debug info - only show in development */}
                    {process.env.NODE_ENV === 'development' && (
                      <div className="text-xs text-gray-500 bg-gray-50 p-2 rounded">
                        <p>Available hospitals: {hospitals.length}</p>
                        <p>Selected: {formData.hospital_id || 'None'}</p>
                        <p>Hospital IDs: {hospitals.map(h => h.hospital_id).join(', ')}</p>
                        
                        {/* Manual hospital selection for testing */}
                        <div className="mt-2 space-y-1">
                          <p className="font-medium">Quick Select (for testing):</p>
                          {hospitals.map(hospital => (
                            <button
                              key={hospital.hospital_id}
                              type="button"
                              onClick={() => {
                                console.log('Manually selecting hospital:', hospital.hospital_id);
                                handleInputChange('hospital_id', hospital.hospital_id);
                              }}
                              className={`block w-full text-left px-2 py-1 rounded text-xs ${
                                formData.hospital_id === hospital.hospital_id 
                                  ? 'bg-blue-100 text-blue-800' 
                                  : 'bg-white text-gray-700 hover:bg-gray-100'
                              }`}
                            >
                              {hospital.hospital_name} (ID: {hospital.hospital_id})
                            </button>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}
                {errors.hospital_id && (
                  <p className="text-red-500 text-xs mt-1">{errors.hospital_id}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Blood Group Type *
                </label>
                <select
                  value={formData.blood_group_type}
                  onChange={(e) => handleInputChange('blood_group_type', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.blood_group_type ? 'border-red-500' : 'border-gray-300'
                  }`}
                >
                  <option value="">Select blood group</option>
                  {bloodGroups.map(group => (
                    <option key={group} value={group}>{group}</option>
                  ))}
                </select>
                {errors.blood_group_type && (
                  <p className="text-red-500 text-xs mt-1">{errors.blood_group_type}</p>
                )}
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Number of Units *
                </label>
                <input
                  type="number"
                  min="1"
                  max="50"
                  value={formData.no_of_units}
                  onChange={(e) => handleInputChange('no_of_units', parseInt(e.target.value))}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.no_of_units ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="1"
                />
                {errors.no_of_units && (
                  <p className="text-red-500 text-xs mt-1">{errors.no_of_units}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Status *
                </label>
                <select
                  value={formData.status}
                  onChange={(e) => handleInputChange('status', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.status ? 'border-red-500' : 'border-gray-300'
                  }`}
                >
                  {statusOptions.map(status => (
                    <option key={status} value={status}>{status}</option>
                  ))}
                </select>
                {errors.status && (
                  <p className="text-red-500 text-xs mt-1">{errors.status}</p>
                )}
              </div>
            </div>
          </div>

          {/* Patient Information */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-lg font-medium text-gray-900 mb-4 flex items-center space-x-2">
              <User size={20} />
              <span>Patient Information</span>
            </h4>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Patient Name *
                </label>
                <input
                  type="text"
                  value={formData.patient_name}
                  onChange={(e) => handleInputChange('patient_name', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.patient_name ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="Enter patient name"
                />
                {errors.patient_name && (
                  <p className="text-red-500 text-xs mt-1">{errors.patient_name}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Required By Date *
                </label>
                <input
                  type="date"
                  value={formData.required_by_date}
                  onChange={(e) => handleInputChange('required_by_date', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.required_by_date ? 'border-red-500' : 'border-gray-300'
                  }`}
                  min={new Date().toISOString().split('T')[0]}
                />
                {errors.required_by_date && (
                  <p className="text-red-500 text-xs mt-1">{errors.required_by_date}</p>
                )}
              </div>
            </div>
          </div>

          {/* Contact Information */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-lg font-medium text-gray-900 mb-4 flex items-center space-x-2">
              <Phone size={20} />
              <span>Contact Information</span>
            </h4>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Patient Contact Email *
                </label>
                <input
                  type="email"
                  value={formData.patient_contact_email}
                  onChange={(e) => handleInputChange('patient_contact_email', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.patient_contact_email ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="Enter contact email"
                />
                {errors.patient_contact_email && (
                  <p className="text-red-500 text-xs mt-1">{errors.patient_contact_email}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Patient Contact Phone Number *
                </label>
                <input
                  type="tel"
                  value={formData.patient_contact_phone_number}
                  onChange={(e) => handleInputChange('patient_contact_phone_number', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.patient_contact_phone_number ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="Enter contact phone number"
                />
                {errors.patient_contact_phone_number && (
                  <p className="text-red-500 text-xs mt-1">{errors.patient_contact_phone_number}</p>
                )}
              </div>
            </div>
          </div>

          {/* Date Range */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-lg font-medium text-gray-900 mb-4 flex items-center space-x-2">
              <Calendar size={20} />
              <span>Date Range</span>
            </h4>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  From Date *
                </label>
                <input
                  type="date"
                  value={formData.from_date}
                  onChange={(e) => handleInputChange('from_date', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.from_date ? 'border-red-500' : 'border-gray-300'
                  }`}
                />
                {errors.from_date && (
                  <p className="text-red-500 text-xs mt-1">{errors.from_date}</p>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  To Date (Optional)
                </label>
                <input
                  type="date"
                  value={formData.to_date}
                  onChange={(e) => handleInputChange('to_date', e.target.value)}
                  className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                    errors.to_date ? 'border-red-500' : 'border-gray-300'
                  }`}
                  min={formData.from_date}
                />
                {errors.to_date && (
                  <p className="text-red-500 text-xs mt-1">{errors.to_date}</p>
                )}
              </div>
            </div>
          </div>

          {/* Description */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Description *
            </label>
            <textarea
              rows={4}
              value={formData.description}
              onChange={(e) => handleInputChange('description', e.target.value)}
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent ${
                errors.description ? 'border-red-500' : 'border-gray-300'
              }`}
              placeholder="Describe the blood request requirements..."
            />
            {errors.description && (
              <p className="text-red-500 text-xs mt-1">{errors.description}</p>
            )}
            <p className="text-xs text-gray-600 mt-1">
              {formData.description.length}/500 characters
            </p>
          </div>
          
          <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200">
            {/* Debug button - only show in development */}
            {process.env.NODE_ENV === 'development' && (
              <button
                type="button"
                onClick={() => {
                  console.log('=== DEBUG INFO ===');
                  console.log('Form data:', formData);
                  console.log('API data:', convertToApiFormat(formData));
                  console.log('User context:', user);
                  console.log('Hospitals:', hospitals);
                  console.log('Available hospital IDs:', hospitals.map(h => h.hospital_id));
                  console.log('Selected hospital_id:', formData.hospital_id);
                  console.log('Is hospital selection valid:', hospitals.find(h => h.hospital_id === formData.hospital_id) ? 'YES' : 'NO');
                  console.log('Errors:', errors);
                  console.log('API URL:', import.meta.env.VITE_API_URL);
                  console.log('Token:', localStorage.getItem('donor-near-me-token') || localStorage.getItem('token'));
                  console.log('Form validation result:', validateForm());
                  console.log('==================');
                }}
                className="px-4 py-2 text-gray-600 hover:text-gray-900 hover:bg-gray-50 border border-gray-300 rounded-md transition-colors"
              >
                Debug Form
              </button>
            )}
            
            <button
              type="button"
              onClick={onClose}
              className="px-6 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 transition-colors"
              disabled={isSubmitting}
            >
              Cancel
            </button>
            <button 
              type="submit"
              disabled={isSubmitting || loadingHospitals || hospitals.length === 0}
              className="flex items-center space-x-2 px-6 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? (
                <>
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  <span>Creating...</span>
                </>
              ) : loadingHospitals ? (
                <>
                  <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                  <span>Loading Hospitals...</span>
                </>
              ) : hospitals.length === 0 ? (
                <>
                  <span>No Hospitals Available</span>
                </>
              ) : (
                <>
                  <Heart size={16} />
                  <span>Create Blood Request</span>
                </>
              )}
            </button>

            {/* Test Create Button */}
            {process.env.NODE_ENV === 'development' && hospitals.length > 0 && (
              <>
                <button 
                  type="button"
                  onClick={handleTestCreate}
                  disabled={isSubmitting}
                  className="flex items-center space-x-2 px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isSubmitting ? (
                    <>
                      <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      <span>Testing...</span>
                    </>
                  ) : (
                    <>
                      <Heart size={16} />
                      <span>Test Create (Dummy Data)</span>
                    </>
                  )}
                </button>

                {/* Force Database Test Button */}
                <button 
                  type="button"
                  onClick={async () => {
                    console.log('=== FORCE DATABASE TEST ===');
                    setIsSubmitting(true);
                    setSubmitError(null);

                    try {
                      if (hospitals.length === 0) {
                        setSubmitError('No hospitals available for test.');
                        return;
                      }

                      const testData = {
                        hospital_id: hospitals[0].hospital_id,
                        blood_group_type: 7,
                        no_of_units: 1,
                        patient_name: 'Force Test Patient - ' + new Date().toLocaleTimeString(),
                        patient_contact_email: 'forcetest@test.com',
                        patient_contact_phone_number: '1234567890',
                        required_by_date: '2025-12-31',
                        description: 'Force database test (bypassing JWT validation)',
                        status: 'pending',
                        from_date: new Date().toISOString().split('T')[0],
                        to_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
                      };

                      console.log('üîÑ Force testing database endpoints...');
                      const testEndpoints = [
                        'http://localhost:5000/blood/request/test',
                        'http://localhost:5000/api/blood/request/test',
                        'http://localhost:5000/test/blood/request',
                        'http://localhost:5000/api/test/blood/request'
                      ];

                      for (const endpoint of testEndpoints) {
                        try {
                          console.log(`Trying: ${endpoint}`);
                          const response = await fetch(endpoint, {
                            method: 'POST',
                            mode: 'cors',
                            headers: {
                              'Content-Type': 'application/json',
                              'Accept': 'application/json'
                            },
                            body: JSON.stringify(testData)
                          });
                          
                          const responseText = await response.text();
                          console.log(`${endpoint} response:`, response.status, responseText);
                          
                          if (response.ok) {
                            console.log(`‚úÖ SUCCESS with: ${endpoint}`);
                            alert(`‚úÖ SUCCESS! Database test worked!\n\nEndpoint: ${endpoint}\nResponse: ${responseText}\n\nCheck your database blood_requests table to confirm the entry was created.`);
                            
                            let result;
                            try {
                              result = JSON.parse(responseText);
                            } catch (e) {
                              result = { id: Date.now().toString(), message: responseText };
                            }

                            const newRequest = {
                              id: result.blood_request_id || result.id || Date.now().toString(),
                              patientName: testData.patient_name,
                              bloodType: 'O+',
                              units: testData.no_of_units,
                              urgency: 'Routine' as const,
                              hospital: hospitals[0].hospital_name,
                              location: hospitals[0].hospital_address,
                              requiredBy: testData.required_by_date,
                              status: 'pending' as const,
                              description: testData.description,
                              contactPhone: testData.patient_contact_phone_number,
                              contactEmail: testData.patient_contact_email,
                              createdAt: new Date().toISOString().split('T')[0],
                              responses: 0
                            };

                            onSubmit(newRequest);
                            return;
                          } else if (response.status === 404) {
                            console.log(`${endpoint}: Not found (expected)`);
                          } else {
                            console.log(`${endpoint}: Failed with ${response.status}`);
                          }
                        } catch (error) {
                          console.log(`${endpoint}: Network error - ${error.message}`);
                        }
                      }

                      // If no test endpoints work, provide instructions
                      setSubmitError(`‚ùå Force database test failed - no test endpoints available.

üîß TO TEST DATABASE FUNCTIONALITY:

**Add this endpoint to your backend:**
\`\`\`python
@app.route('/blood/request/test', methods=['POST'])
def create_blood_request_test():
    try:
        data = request.get_json()
        
        # Create blood request without authentication
        blood_request = BloodRequest(
            hospital_id=data['hospital_id'],
            blood_group_type=data['blood_group_type'],
            no_of_units=data['no_of_units'],
            patient_name=data['patient_name'],
            patient_contact_email=data['patient_contact_email'],
            patient_contact_phone_number=data['patient_contact_phone_number'],
            required_by_date=data['required_by_date'],
            description=data['description'],
            status=data['status'],
            from_date=data['from_date'],
            to_date=data.get('to_date'),
            user_id=33  # Use the user ID from your JWT token (33)
        )
        
        db.session.add(blood_request)
        db.session.commit();
        
        return jsonify({
            "success": True,
            "blood_request_id": blood_request.id,
            "message": "Test blood request created successfully",
            "data": {
                "id": blood_request.id,
                "patient_name": blood_request.patient_name,
                "blood_group_type": blood_request.blood_group_type,
                "hospital_id": blood_request.hospital_id,
                "status": blood_request.status,
                "user_id": blood_request.user_id
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        print(f"Test endpoint error: {str(e)}")
        return jsonify({
            "error": f"Failed to create test blood request: {str(e)}",
            "success": False
        }), 500
\`\`\`

Then click "Force Database Test" again to test database functionality!`);

                    } catch (error) {
                      console.error('Force test error:', error);
                      setSubmitError(`Force test failed: ${error.message}`);
                    } finally {
                      setIsSubmitting(false);
                    }
                  }}
                  disabled={isSubmitting}
                  className="flex items-center space-x-2 px-6 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isSubmitting ? (
                    <>
                      <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                      <span>Testing...</span>
                    </>
                  ) : (
                    <>
                      <AlertCircle size={16} />
                      <span>Force Database Test</span>
                    </>
                  )}
                </button>
              </>
            )}
          </div>
        </form>
      </div>
    </div>
  );
};

export default CreateRequestForm;